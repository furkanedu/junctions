webpackJsonp([9],{126:function(e,o,t){e.exports=t(1).markdownPostProcessor('<p><strong>Note: The Guide is still only an outline. <a href="%%%SITEPACK_LINK%%%/docs/basics/github.com/jamesknelson/junctions%%%END_SITEPACK_LINK%%%">Pull Requests</a> would be greatly appreciated!</strong></p>\n<p><em>Junctions</em> is a single tool for converting between Routes and Locations – and that’s it. But while this gives you a huge amount of flexibility, it can also leave you scratching your head as to the best way to use it.</p>\n<p><strong>Screen Components</strong> are a solution to this. They’re a pattern for components which specify junctions and consume matching routes. And while they still give you flexibility to use <em>Junctions</em> whichever way you see fit, they take the guesswork out of getting started.</p>\n<p>So what do Screen components look like?</p>\n<ul>\n<li>They have a static <code>junction</code> property</li>\n<li>They accept a <code>route</code> prop</li>\n<li>Their route’s <code>child</code>, if it exists, is passed to a child screen</li>\n</ul>\n<p>For example:</p>\n<p><strong>TODO: example</strong></p>\n<p>Let’s go over this example one step at a time</p>\n<h2 id="the-static-property"><a class="header-anchor" href="#the-static-property" aria-hidden="true">#</a> The static <code>junction</code> property</h2>\n<ul>\n<li>Like React’s <code>propTypes</code>, this specifies the types which can be passed in</li>\n<li>But unlike <code>propTypes</code>, it is actually used at runtime in production:\n<ul>\n<li>If this is the root screen, the converter will use it directly</li>\n<li>If this is a nested screen, the parent screen’s Junction needs to access it\n<strong>TODO: example</strong></li>\n</ul>\n</li>\n<li>Because we know that any screen component has a <code>junction</code> property, composing screens becomes simply a matter of passing that junction to our junction branch’s <code>child</code> property</li>\n</ul>\n<h2 id="the-prop"><a class="header-anchor" href="#the-prop" aria-hidden="true">#</a> The <code>route</code> prop</h2>\n<ul>\n<li>A screen’s <em>current</em> Route object is always passed in via the component’s <code>route</code> prop</li>\n<li>This route will match one of the junction branches specified on the screen’s junction, as we trust that anybody using a screen knows where to find our Junction</li>\n</ul>\n<h2 id="handling-routes-property"><a class="header-anchor" href="#handling-routes-property" aria-hidden="true">#</a> Handling route’s <code>child</code> property</h2>\n<ul>\n<li>If a Screen component’s Junction specifies child Screens, then a Screen needs to handle the routes for child screens too.</li>\n<li>To do so, the screen should pass its <code>route.child</code> through to the child Screen’s <code>route</code> prop</li>\n<li><code>route.child</code> will differ based on which branch is currently active, so regardless of which child component you’re rendering for the current route, <em>its</em> children will still be <code>route.child</code></li>\n</ul>\n')}});