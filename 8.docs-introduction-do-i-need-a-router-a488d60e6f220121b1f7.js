webpackJsonp([8],{127:function(n,s,a){n.exports=a(1).markdownPostProcessor('<p>So you’ve decided to build a new React app. And usually, your first step would be to add a routing library. <em>But do you really need one?</em></p>\n<!--more-->\n<h2 id="what-routers-do"><a class="header-anchor" href="#what-routers-do" aria-hidden="true">#</a> What Routers Do</h2>\n<p>The first step to understand whether you need a routing library is to understand what routing libraries do. Which is something along the lines of:</p>\n<ul>\n<li>Smooth over inconsistencies between browsers</li>\n<li>Provide helpers for working with React</li>\n<li>Respond to browser navigation events</li>\n</ul>\n<p>Of course, most routing libraries do a lot more. But we probably don’t <em>need</em> features like loading entire scripts dynamically or JSX-based definitions of available routes. So let’s keep to the basics as we go over the details.</p>\n<h3 id="smoothing-over-inconsistencies-between-browsers"><a class="header-anchor" href="#smoothing-over-inconsistencies-between-browsers" aria-hidden="true">#</a> Smoothing over inconsistencies between browsers</h3>\n<p>While modern web browsers supposedly all respect the same standards, the reality is that each browser still has its own quirks. Not to mention that the standards sometimes leave a little room for interpretation.</p>\n<p>One example is the <a href="https://developer.mozilla.org/en-US/docs/Web/Events/popstate">popstate</a> event. The browser emits this every time time the location changes. Or at least some browsers do; Chrome and Firefox also emit it on load, while safari doesn’t. And none of the browsers emit it when <em>you</em> change the state by calling <a href="https://developer.mozilla.org/en-US/docs/Web/API/History_API#The_pushState()_method">pushState()</a>.</p>\n<p>To write a router using the browser’s raw History API, we’d need to smooth over all these differences. And even then, our application shouldn’t care <em>why</em> the location changed – it should respond to navigation events regardless. Given all this, it seems like the browser API is going to make life difficult for us. So does that mean we need a routing library? Kind of. But kind of not.</p>\n<p><em>It means we need a browser inconsistency smoothing library.</em></p>\n<p>And thats what the <a href="https://github.com/mjackson/history">history</a> package is for. <a href="https://github.com/ReactTraining/react-router">react-router</a> uses it internally, but it is a completely independent library. And it is a very useful library too. It lets you avoid all the browser inconsistencies by sticking to this pretty simple API:</p>\n<pre><code class="language-js"><span class="token keyword" >import</span> createHistory <span class="token keyword" >from</span> <span class="token string" >\'history/createBrowserHistory\'</span>\n<span class="token keyword" >const</span> history <span class="token operator" >=</span> <span class="token function" >createHistory</span><span class="token punctuation" >(</span><span class="token punctuation" >)</span>\n\n<span class="token keyword" >function</span> <span class="token function" >handleNavigation</span><span class="token punctuation" >(</span>location<span class="token punctuation" >)</span> <span class="token punctuation" >{</span>\n  console<span class="token punctuation" >.</span><span class="token function" >log</span><span class="token punctuation" >(</span>location<span class="token punctuation" >.</span>pathname<span class="token punctuation" >)</span>\n<span class="token punctuation" >}</span>\n\n<span class="token comment" spellcheck="true">// Handle the initial location</span>\n<span class="token function" >handleNavigation</span><span class="token punctuation" >(</span>history<span class="token punctuation" >.</span>location<span class="token punctuation" >)</span>\n\n<span class="token comment" spellcheck="true">// Handle subsequent navigation events</span>\nhistory<span class="token punctuation" >.</span><span class="token function" >listen</span><span class="token punctuation" >(</span>handleNavigation<span class="token punctuation" >)</span>\n</code></pre>\n<p>Ok, so with history, we now have access to the latest location. But these history objects present a new problem: <code>&lt;a&gt;</code> tags don’t work with the History API. In fact, every time we click an <code>&lt;a&gt;</code> which holds anything other than a hash fragment like <code>#butterflies</code>, the entire page reloads! In order to navigate without a page reload, we’ll need to call <code>history.push()</code>. And to do that, a routing library will often supply some tools.</p>\n<h3 id="helpers-for-working-with-react"><a class="header-anchor" href="#helpers-for-working-with-react" aria-hidden="true">#</a> Helpers for working with React</h3>\n<p>Because of the situation with <code>&lt;a&gt;</code> not working with push state, you’ll find that routing libraries include a fix. This commonly takes the form of a <code>&lt;Link&gt;</code> component – which renders an <code>&lt;a&gt;</code>, but adds an <code>onClick</code> handler to capture any clicks and redirect them to <code>history.push()</code>. In practice, this looks something like this:</p>\n<pre><code class="language-js"><span class="token keyword" >class</span> <span class="token class-name" >Link</span> <span class="token keyword" >extends</span> <span class="token class-name" >React<span class="token punctuation" >.</span>component</span> <span class="token punctuation" >{</span>\n  <span class="token function" >constructor</span><span class="token punctuation" >(</span>props<span class="token punctuation" >)</span> <span class="token punctuation" >{</span>\n    <span class="token keyword" >super</span><span class="token punctuation" >(</span>props<span class="token punctuation" >)</span>\n\n    <span class="token comment" spellcheck="true">// The `bind` is necessary to make `this` work within the `handleClick`  </span>\n    <span class="token keyword" >this</span><span class="token punctuation" >.</span>handleClick <span class="token operator" >=</span> <span class="token keyword" >this</span><span class="token punctuation" >.</span>handleClick<span class="token punctuation" >.</span><span class="token function" >bind</span><span class="token punctuation" >(</span><span class="token keyword" >this</span><span class="token punctuation" >)</span>\n  <span class="token punctuation" >}</span>\n\n  <span class="token function" >handleClick</span><span class="token punctuation" >(</span>event<span class="token punctuation" >)</span> <span class="token punctuation" >{</span>\n    <span class="token keyword" >if</span> <span class="token punctuation" >(</span>event<span class="token punctuation" >.</span>defaultPrevented <span class="token operator" >||</span>\n        <span class="token function" >isModifiedEvent</span><span class="token punctuation" >(</span>event<span class="token punctuation" >)</span> <span class="token operator" >||</span>\n        <span class="token operator" >!</span><span class="token function" >isLeftClickEvent</span><span class="token punctuation" >(</span>event<span class="token punctuation" >)</span><span class="token punctuation" >)</span> <span class="token punctuation" >{</span>\n      <span class="token keyword" >return</span>\n    <span class="token punctuation" >}</span>\n\n    event<span class="token punctuation" >.</span><span class="token function" >preventDefault</span><span class="token punctuation" >(</span><span class="token punctuation" >)</span>\n\n    <span class="token comment" spellcheck="true">// It only makes sense for an application to have one history, so we can</span>\n    <span class="token comment" spellcheck="true">// make it global</span>\n    history<span class="token punctuation" >.</span><span class="token function" >push</span><span class="token punctuation" >(</span><span class="token keyword" >this</span><span class="token punctuation" >.</span>props<span class="token punctuation" >.</span>to<span class="token punctuation" >)</span>\n  <span class="token punctuation" >}</span>\n\n  <span class="token function" >render</span><span class="token punctuation" >(</span><span class="token punctuation" >)</span> <span class="token punctuation" >{</span>\n    <span class="token keyword" >var</span> props <span class="token operator" >=</span> Object<span class="token punctuation" >.</span><span class="token function" >assign</span><span class="token punctuation" >(</span><span class="token punctuation" >{</span><span class="token punctuation" >}</span><span class="token punctuation" >,</span> <span class="token keyword" >this</span><span class="token punctuation" >.</span>props<span class="token punctuation" >)</span>\n\n    \n    props<span class="token punctuation" >.</span>onClick <span class="token operator" >=</span> <span class="token keyword" >this</span><span class="token punctuation" >.</span>handleClick\n    props<span class="token punctuation" >.</span>href <span class="token operator" >=</span> <span class="token keyword" >this</span><span class="token punctuation" >.</span>props<span class="token punctuation" >.</span>to<span class="token punctuation" >.</span>pathname <span class="token operator" >+</span> <span class="token punctuation" >(</span><span class="token keyword" >this</span><span class="token punctuation" >.</span>props<span class="token punctuation" >.</span>to<span class="token punctuation" >.</span>search <span class="token operator" >||</span> <span class="token string" >\'\'</span><span class="token punctuation" >)</span>\n    <span class="token keyword" >delete</span> <span class="token keyword" >this</span><span class="token punctuation" >.</span>props<span class="token punctuation" >.</span>to\n\n    <span class="token keyword" >return</span> <span class="token operator" >&lt;</span>a <span class="token punctuation" >{</span><span class="token punctuation" >.</span><span class="token punctuation" >.</span><span class="token punctuation" >.</span>props<span class="token punctuation" >}</span><span class="token operator" >></span><span class="token punctuation" >{</span>props<span class="token punctuation" >.</span>children<span class="token punctuation" >}</span><span class="token tag" ><span class="token tag" ><span class="token punctuation" >&lt;/</span>a</span><span class="token punctuation" >></span></span>\n  <span class="token punctuation" >}</span>\n<span class="token punctuation" >}</span>\n</code></pre>\n<p>A full featured implementation of <code>&lt;Link&gt;</code> will probably want a few extra features; for example, accepting a <code>history</code> object from <a href="https://facebook.github.io/react/docs/context.html">Context</a>. But even with these features, <code>&lt;Link&gt;</code> doesn’t need to be hugely complicated. After all, <code>&lt;a&gt;</code> isn’t hugely complicated either.</p>\n<p>And while most routing libraries will probably provide some other bits and pieces, it is unlikely you’ll actually need them. I mean, you don’t even really need a <code>&lt;Link&gt;</code> component; if you use a <a href="http://jamesknelson.com/push-state-vs-hash-based-routing-with-react-js/">hash based</a> router instead, then you’ll be fine without it. But assuming you’re using push state, it isn’t a huge problem to just roll your own.</p>\n<p>So maybe we don’t need a routing library? But there is still one thing we need to take care of. Even if we can render <code>&lt;Link&gt;</code> tags and receive a notification when the user navigates, we still don’t know what to actually <em>do</em> with the received locations.</p>\n<h3 id="responding-to-browser-navigation-events"><a class="header-anchor" href="#responding-to-browser-navigation-events" aria-hidden="true">#</a> Responding to browser navigation events</h3>\n<p>Given we have a <code>history.listen()</code> handler, our application is going to receive a series of <code>location</code> objects. Each one looks something like this:</p>\n<pre><code class="language-js"><span class="token punctuation" >{</span>\n  pathname<span class="token punctuation" >:</span> <span class="token string" >\'/todos\'</span><span class="token punctuation" >,</span>\n  search<span class="token punctuation" >:</span> <span class="token string" >\'?page=2\'</span><span class="token punctuation" >,</span>\n  state<span class="token punctuation" >:</span> <span class="token punctuation" >{</span>\n    some_arbitrary_stuff<span class="token punctuation" >:</span> <span class="token string" >\'人参\'</span>\n  <span class="token punctuation" >}</span>\n<span class="token punctuation" >}</span>\n</code></pre>\n<p>You can think of these locations as one way of specifying what the application should render. For example, the object above may specify that we’d like to see page two of a <em>Todos</em> screen. Easy, right?</p>\n<p>But let me ask you a question. Given the user has just clicked a <code>&lt;Link&gt;</code> and we’ve received this new location, <em>how does React know what to actually render</em>? And this brings up another question: <em>how does React even know it has to re-render?</em></p>\n<h4 id="telling-react-about-location-changes"><a class="header-anchor" href="#telling-react-about-location-changes" aria-hidden="true">#</a> Telling React about location changes</h4>\n<p>One of the best things about React is that it is pretty dumb. It doesn’t try and guess when things like your location change. You need to tell it.</p>\n<p>The most common way of doing so is with a component’s <a href="https://facebook.github.io/react/docs/react-component.html#setstate">setState()</a> method. But in order to use <code>setState()</code> from within our navigation handler, our handler will need to have access to <code>setState()</code>. And this means that we’ll need to create the handler function and pass it to <code>history.listen()</code> within the component itself. Like this:</p>\n<pre><code class="language-js"><span class="token keyword" >class</span> <span class="token class-name" >Application</span> <span class="token keyword" >extends</span> <span class="token class-name" >React<span class="token punctuation" >.</span>Component</span> <span class="token punctuation" >{</span>\n  <span class="token function" >constructor</span><span class="token punctuation" >(</span>props<span class="token punctuation" >)</span> <span class="token punctuation" >{</span>\n    <span class="token keyword" >super</span><span class="token punctuation" >(</span>props<span class="token punctuation" >)</span>\n\n    <span class="token keyword" >this</span><span class="token punctuation" >.</span>state <span class="token operator" >=</span> <span class="token punctuation" >{</span>\n      location<span class="token punctuation" >:</span> history<span class="token punctuation" >.</span>location\n    <span class="token punctuation" >}</span>\n\n    history<span class="token punctuation" >.</span><span class="token function" >listen</span><span class="token punctuation" >(</span><span class="token keyword" >this</span><span class="token punctuation" >.</span>handleNavigation<span class="token punctuation" >.</span><span class="token function" >bind</span><span class="token punctuation" >(</span><span class="token keyword" >this</span><span class="token punctuation" >)</span><span class="token punctuation" >)</span>\n  <span class="token punctuation" >}</span>\n\n  <span class="token function" >handleNavigation</span><span class="token punctuation" >(</span>location<span class="token punctuation" >)</span> <span class="token punctuation" >{</span>\n    <span class="token keyword" >this</span><span class="token punctuation" >.</span><span class="token function" >setState</span><span class="token punctuation" >(</span><span class="token punctuation" >{</span>\n      location<span class="token punctuation" >:</span> location<span class="token punctuation" >,</span>\n    <span class="token punctuation" >}</span><span class="token punctuation" >)</span>\n  <span class="token punctuation" >}</span>\n\n  <span class="token comment" spellcheck="true">// ...</span>\n<span class="token punctuation" >}</span>\n</code></pre>\n<p>With this, you can now always access the most recent location at <code>this.state.location</code>. So the obvious question is: what should you actually do with it?</p>\n<h4 id="rendering-your-routes"><a class="header-anchor" href="#rendering-your-routes" aria-hidden="true">#</a> Rendering your routes</h4>\n<p>In React, rendering your routes is really no different than rendering anything else. You just take the location at <code>this.state.location</code>, and return an element based on its value. Like this:</p>\n<pre><code class="language-js"><span class="token function" >render</span><span class="token punctuation" >(</span><span class="token punctuation" >)</span> <span class="token punctuation" >{</span>\n  <span class="token keyword" >const</span> pathname <span class="token operator" >=</span> <span class="token keyword" >this</span><span class="token punctuation" >.</span>state<span class="token punctuation" >.</span>location<span class="token punctuation" >.</span>pathname\n\n  <span class="token keyword" >if</span> <span class="token punctuation" >(</span>pathname <span class="token operator" >===</span> <span class="token string" >\'/todos\'</span><span class="token punctuation" >)</span> <span class="token punctuation" >{</span>\n    <span class="token keyword" >return</span> <span class="token tag" ><span class="token tag" ><span class="token punctuation" >&lt;</span>Todos</span> <span class="token attr-name" >search</span><span class="token script language-javascript" ><span class="token punctuation" >=</span><span class="token punctuation" >{</span><span class="token keyword" >this</span><span class="token punctuation" >.</span>state<span class="token punctuation" >.</span>location<span class="token punctuation" >.</span>search<span class="token punctuation" >}</span></span> <span class="token punctuation" >/></span></span>\n  <span class="token punctuation" >}</span>\n  <span class="token keyword" >else</span> <span class="token keyword" >if</span> <span class="token punctuation" >(</span>pathname <span class="token operator" >===</span> <span class="token string" >\'/reminders\'</span><span class="token punctuation" >)</span> <span class="token punctuation" >{</span>\n    <span class="token keyword" >return</span> <span class="token tag" ><span class="token tag" ><span class="token punctuation" >&lt;</span>Reminders</span> <span class="token attr-name" >search</span><span class="token script language-javascript" ><span class="token punctuation" >=</span><span class="token punctuation" >{</span><span class="token keyword" >this</span><span class="token punctuation" >.</span>state<span class="token punctuation" >.</span>location<span class="token punctuation" >.</span>search<span class="token punctuation" >}</span></span> <span class="token punctuation" >/></span></span>\n  <span class="token punctuation" >}</span>\n  <span class="token keyword" >else</span> <span class="token punctuation" >{</span>\n    <span class="token keyword" >return</span> <span class="token tag" ><span class="token tag" ><span class="token punctuation" >&lt;</span>NotFound</span> <span class="token punctuation" >/></span></span>\n  <span class="token punctuation" >}</span>\n<span class="token punctuation" >}</span>\n</code></pre>\n<p>Simple, right? Or at least, simple so long as we don’t add a bunch more routes. Once your application starts to grow in size, you’re going to want to find a better way of processing the location than a giant <code>if-else</code> or <code>switch</code> statement. And that is going to mean a better way of representing the Location than two gnarly strings.</p>\n<p>The thing about the two strings you get from a <code>Location</code> object is they’re made that way due to browser limitations. The browser has a URL bar, so your application receives URLs – even if it would make way more sense to receive some sort of <em>Route</em> object which matches the structure of your application.</p>\n<p>This is where routing libraries really do shine – they can convert <code>Location</code> objects into something more useful. Or to put it another way, good libraries add useful functionality. They don’t replace it.</p>\n<h2 id="to-route-or-not-to-route"><a class="header-anchor" href="#to-route-or-not-to-route" aria-hidden="true">#</a> To Route Or Not To Route</h2>\n<p>But to return to the original question; <em>do I even need a routing library?</em> The answer is (of course) it depends.</p>\n<p>Are you writing a simple application where you’ve got few enough URLs that a simple <code>&lt;Application&gt;</code> component is easily comprehensible? Then you probably don’t need a routing library. Using the history package with a custom <code>&lt;Link&gt;</code> component is nice and simple. And if your application grows, you can always add appropriate tools down the track.</p>\n<p>But maybe your URLs are complex enough that you’d like to break them down into more manageable parts. Or maybe you want individual screens to manage their own routes – as opposed to a single application-wide <code>&lt;Application&gt;</code> component. Or maybe you just want some well-defined patterns to follow. In this case, Junctions is just what you need!</p>\n')}});