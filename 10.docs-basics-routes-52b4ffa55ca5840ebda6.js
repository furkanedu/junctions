webpackJsonp([10],{125:function(e,n,o){e.exports=o(1).markdownPostProcessor('<p><strong>Note: The Guide is still only an outline. <a href="%%%SITEPACK_LINK%%%/docs/basics/github.com/jamesknelson/junctions%%%END_SITEPACK_LINK%%%">Pull Requests</a> would be greatly appreciated!</strong></p>\n<ul>\n<li>A <code>Route</code> is an object which contains a portion of your app’s Navigation state.</li>\n<li>But where a <code>Location</code> describes the state of your entire application, a <code>Route</code> typically describes the portion of navigation state corresponds to one specific component within your application</li>\n</ul>\n<p><strong>TODO: Example of screen which can render one of two routes, each with different keys</strong></p>\n<ul>\n<li>\n<p>You’ll often render different types of components based on the key. But how can you pass other information to the component?</p>\n</li>\n<li>\n<p>Route objects can also hold a <strong>params</strong> object with further details on the route</p>\n</li>\n<li>\n<p>Example of a screen rendering something based on its parameters</p>\n</li>\n</ul>\n<h2 id="nesting-routes"><a class="header-anchor" href="#nesting-routes" aria-hidden="true">#</a> Nesting Routes</h2>\n<ul>\n<li>Each Route represents the navigation state of a single Screen. But what happens if one Screen contains another screen?</li>\n<li><em>The Route for the parent screen must contain the Route for the child screen.</em></li>\n<li>This is accomplished through the <strong>children</strong> property of a Route.</li>\n</ul>\n<p><strong>TODO: Example of a Route which holds another Route under its children property</strong></p>\n<ul>\n<li>\n<p>One of the most important concepts to grasp about Junctions is that <strong>Routes are relative</strong>.</p>\n</li>\n<li>\n<p>Routes only ever contain the information about their state and their children’s state. But they don’t know anything about their parents.</p>\n</li>\n<li>\n<p>This means that any Route can be included in the children of another Route. And <strong>any navigable screen can be mounted in any other navigable screen</strong></p>\n</li>\n<li>\n<p>Example where the above route is mounted inside another screen, along with screen code</p>\n</li>\n</ul>\n<h2 id="routes-are-like-onions"><a class="header-anchor" href="#routes-are-like-onions" aria-hidden="true">#</a> Routes are like Onions</h2>\n<ul>\n<li>One way of visualising this is to think of Routes as onions.</li>\n</ul>\n<p><strong>TODO: Image: Onion vs. Route</strong></p>\n<ul>\n<li>\n<p>Like an onion, Each Route can contain a number of layers, linked by <code>children</code> properties.</p>\n</li>\n<li>\n<p>Also like an onion, you only have access to the outermost layer of an Route.</p>\n</li>\n<li>\n<p>But luckily, one screen generally only needs access to the information in the outermost layer.</p>\n</li>\n<li>\n<p>Once we’ve got our information, we can peel off that layer by accessing the <code>children</code> prop, and passing it through to our child Screen.</p>\n</li>\n<li>\n<p>Conversely, just because we have a route, we cannot say where it came from. It may have had many layers. Thus routes must be relative.</p>\n</li>\n<li>\n<p>In fact, its not just Routes which are like onions. React components are like onions too.</p>\n</li>\n</ul>\n<p><strong>TODO: Image: React Component Block Diagram vs. Route Object block Diagram</strong></p>\n<ul>\n<li>\n<p>It is this similarity that allows Junctions to meet its third principle: Pass your own props</p>\n</li>\n<li>\n<p>Because the structures of React components and Route objects are so similar, manually passing the correct information to a child component is as simple as peeling off a layer and passing in the result.</p>\n</li>\n<li>\n<p>Both React Components and Junctions <code>Route</code> objects do not include any information about their original context. In onion terms, once you peel a layer away from a Route, the remaining Route will not know that the layer existed.</p>\n</li>\n<li>\n<p>But even if a Route doesn’t know where it came from, it still has to have come from somewhere.</p>\n</li>\n</ul>\n<h2 id="the-root-route"><a class="header-anchor" href="#the-root-route" aria-hidden="true">#</a> The Root Route</h2>\n<ul>\n<li>Your Root route is the single Route object within your application which is absolute.</li>\n<li>This is the Route which corresponds to the most top-level Screen in your application</li>\n<li>It also contains all the information in your application’s current <code>Location</code>.</li>\n<li>But the route is only absolute in some contexts.</li>\n<li>It isn’t absolute when used within a screen.</li>\n<li>So what makes it absolute?</li>\n<li>The thing which makes this route absolute isn’t that it contains this information, but that you <em>know</em> there are no parent layers. And you know this because you’ll have built this Route by converting a <code>Location</code></li>\n<li>You could do this conversion manually. But this package provides helpers to do it for you. And to do so, it’ll need a Map. And that map is composed of <code>Junction</code> objects.</li>\n</ul>\n')}});